---
title: 사용자 수에 따른 규모 확장성
date: 2025-11-22
category: System Design
excerpt: [가상면접 사례로 배우는 대규모 시스템 설계 기초] 스터디 1주차 학습 정리
---

## 가용성과 안정성의 차이가 무엇일까?

### 가용성 (Availability)

> 사용자가 서비스를 이용할 수 있는 시간의 비율 (예: 99.999%)
> 
- 예시
    - 우리 서비스가 24시간 중 23시간 59분 정상 동작했다 → 가용성 높음
    - 배포 중에 5분 동안 서버가 다운됨 → 가용성 낮음
- 가용성을 높이기 위해 신경써야하는 것들
    1. 장애가 나면 다른 서버로 넘어가는 Failover
    2. 서버를 여러 대 두는 중복성(Redundancy)
    3. 트래픽을 나눠 처리하는 Load Balancing

![image.png](attachment:18054b77-282f-46b1-92b8-8cefb0460cb5:image.png)

### 안정성 (Reliability)

> 서비스가 ‘살아 있을 때’, 얼마나 정확하게 동작하느냐
> 
- 예시
    - 서버는 켜져 있는데 주문이 10번 중 1번 실패 → 가용성은 높지만 안정성은 낮다
    - 응답은 빠르지만 가끔 잘못된 데이터 반환 → 안정성 낮음
    - 재시도할 때마다 결과가 매번 다름 → 안정성 낮음
- 안정성을 높이기 위해 신경써야하는 것들
    1. 트랜잭션 처리 (정합성 유지)
    2. 예외 처리, 재시도 전략
    3. 테스트 코드 (특히 단위·통합 테스트)
    4. 예측 가능한 API 동작
    5. 데이터 무결성 유지
- **가용성(Availability)** 보다 **안정성(Reliability)** 이 훨씬 중요하다!
  - 안정성이 보장되지 않으면 높은 가용성은 의미가 없으며, 안정성을 최적화한 후 가용성을 높이는 것이 가장 이상적인 접근 방식이다.
  - 예를 들어, Amazon에서 주문 API가 99.99%의 가용성을 유지하지만, 일부 주문이 정상적으로 처리되지 않는다면 고객 불만이 증가할 것이다.

## Master/Slave 아키텍처에서 복제(Replication)는 어떻게 이루어질까?

### Binlog 기반 복제

- MySQL에서 **Master–Slave 구조로 데이터를 복제하는 방식** 중 하나
- **동작 방식 (MySQL 기준)**
    1. **클라이언트가 Master 서버에 데이터 쓰기를 요청**
    2. **마스터 서버는 해당 정보를 Binary Log라는 임시(temp) 파일에 저장**
    3. **Slave가 Master에 연결**
        - Slave 서버의 IO Thread가 Master에 TCP 연결을 맺음
        - 마지막으로 읽은 binlog 위치(position)를 Master에게 전달
    4. **Master → Slave Binlog 전송**
        - Master는 Slave에게 새로 생성된 Binlog 이벤트를 스트리밍 형태로 전송
        - 이벤트가 없으면 연결을 유지하며 대기
        - 이벤트가 생기면 즉시 Slave에게 전달
    5. **Slave 이벤트 처리**
        - Slave는 받은 이벤트를 Relay Log라는 임시 파일에 기록
        - Slave의 SQL Thread가 Relay Log를 읽어 데이터베이스에 동일하게 적용
- Slave는 데이터를 직접 요청하지 않고, Master가 이벤트를 보내주는(push) 구조
- 왜 Binlog 기반 복제를 사용할까?

### 1. 비동기 복제 **(Asynchronous Replication)**

> **마스터는 슬레이브가 데이터를 받았는지 확인하지 않고 바로 응답한다.**
> 
- 가장 널리 사용하는 방식 (MySQL 기본)
- **동작 방식**
    1. 마스터에 INSERT/UPDATE 수행
    2. 마스터는 binlog만 기록하면 바로 “성공” 응답
    3. 그 이후 슬레이브가 천천히 binlog를 따라감
- **장점**
    - 겁나 빠름 → 마스터의 쓰기 성능 최대 보장
    - 트래픽 폭주에도 강함
- **단점**
    - 슬레이브 복제 지연(replication lag) 발생 가능
    - 마스터 장애 시 데이터 유실 위험 있음 → 슬레이브가 아직 못 데이터를 못 받았다면..?
- **예시 상황**
    - 마스터에 주문 저장 → 성공 응답
    - 0.5초 후 슬레이브로 복제됨 → 이때까지는 슬레이브에서 조회하면 주문이 안 보일 수 있음

### 2. 준동기 복제 (**Semi-Synchronous Replication**)

> **마스터는 최소 하나의 슬레이브가 “binlog를 받았다”는 ACK를 줄 때까지 기다린다.**
> 
- 속도와 안정성의 절충안
- **동작 방식**
    1. 마스터가 binlog 작성
    2. 최소 1개의 슬레이브가 binlog 수신 → ACK 전송
    3. ACK를 받으면 마스터가 사용자에게 성공 응답
    4. 슬레이브 적용은 나중에 진행됨
- **장점**
    - 하나의 복제본은 반드시 최신 데이터 보유 → 데이터 유실 가능성 낮아짐
- **단점**
    - 비동기보다 약간 느림
    - 슬레이브가 느리면 마스터 응답 속도도 같이 느려짐
- **예시**
    - 마스터에 주문 저장
    - 최소 한 개 슬레이브가 “받았다!”라고 말해야 마스터가 성공 응답

### 3. 동기 복제 (**Synchronous Replication**)

> **모든 슬레이브가 데이터를 실제로 적용(commit)할 때까지 마스터가 응답하지 않는다.**
> 
- 가장 안전하지만 가장 느림
- 금융/결제 등 절대 데이터 유실이 허용되지 않는 곳에서 사용
- **동작 방식**
    1. 마스터가 트랜잭션 수행
    2. 모든 슬레이브가 트랜잭션 적용 완료 후 ACK
    3. 마스터가 사용자에게 성공 응답
- **장점**
    - 데이터 정합성 100% 보장
    - 장애 발생해도 데이터 손실 없음
- **단점**
    - 가장 느림
    - 슬레이브 한 대라도 지연되면 전체 속도가 느려짐
- **예시**
    - “잘 저장했는지 슬레이브 전부 확인하고 응답할게!” 느낌

## 참고 자료

- [주니어 백엔드 개발자가 반드시 알아야 할 실무 지식](https://product.kyobobook.co.kr/detail/S000216376461?utm_source=google&utm_medium=cpc&utm_campaign=googleSearch&gt_network=g&gt_keyword=&gt_target_id=dsa-435935280379&gt_campaign_id=9979905549&gt_adgroup_id=132556570510&gad_source=1)

